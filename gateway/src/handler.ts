/**
 * Layer between Discord-formatted JSON objects and game logic. 
 */

import { InteractionResponseType, InteractionResponseFlags, InteractionType } from 'discord-interactions';
import { handleDig } from './game/dig';
import { handleError } from './game/error';
import { handlePoke } from './game/poke';

async function getGameResponse(interaction: InteractionRequest) : Promise<GameResponse> {

	// "name" should be the name of the command (/dig, etc)
	// interactionCommand and subcommand are only relevant for interactions generated by message components
	let name = interaction.data?.name;
	let interactionCommand;
	let subcommand;

	if (name === undefined) {
		const customId = interaction.data?.custom_id;
		if (customId != undefined) {
			interactionCommand = customId.split(';');
			name = interactionCommand[0];
			subcommand = interactionCommand[1];
		}
	}

	switch (name) {
		case "dig":
			return await handleDig(interaction.guild_id, interaction.channel_id, subcommand);
		case "poke":
			return await handlePoke();
		default:
			return await handleError();
	}
}

export async function handleInteraction(interaction: InteractionRequest) : Promise<Object> {

	if (interaction.type == InteractionType.PING) {
		return { 
			type: InteractionResponseType.PONG
		};
	}

	const response = await getGameResponse(interaction);

	const buttons = response.buttons.map((button: {text: string, stage: string}) => {
		return {
			"type": 2,
			"label": button.text,
			"style": 1,
			"custom_id": button.stage
		}		
	})

	const components = buttons.length == 0 ? [] : 
		[{
			"type": 1,
			"components": buttons
		}];

	return {
		"type": InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
		"data": {
			"tts": false,
			"content": response.msg,
			"components": components,
			"flags": InteractionResponseFlags.EPHEMERAL,
			"embeds": [],
			"allowed_mentions": { "parse": [] }
		}
	};
}
